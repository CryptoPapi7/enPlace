# enPlace Development TODO - Session Continuation Document

**Created:** 2026-02-17 15:45 UTC  
**Status:** Rate limit pause - resume in new session  
**Current Phase:** Just completed Phase 2 (Images + Tonkotsu Ramen)

---

## ‚úÖ COMPLETED TODAY

### Phase 1: Foundation Fixes
- ‚úÖ Fixed hard-coded servings bug in CookScreen (now uses effectiveServings)

### Phase 2: Visual Upgrade  
- ‚úÖ Added `imageUrl` field to recipe schema
- ‚úÖ Created Tonkotsu Ramen recipe (8-hour project, full details)
- ‚úÖ Updated RecipeLibraryScreen to display images on cards
- ‚úÖ Updated RecipeScreen to show hero image
- ‚úÖ Updated HomeScreen trending cards to show images
- ‚úÖ Added fallback to emoji when no image exists
- ‚úÖ Wired up all route mappings (RecipeScreen, CookScreen)

---

## üîÑ REMAINING WORK (Pick up in new session)

### Phase 3: Cook Mode Quality (IN PROGRESS)
**Priority:** HIGH

#### 3.1 Fix Blank/Short Steps Bug
- **Issue:** Cook mode shows steps with blank instructions or single words
- **Root cause:** Recipe data has incomplete entries
- **File:** Need to audit `/data/recipes/*.ts` files
- **Action:** Clean up recipe sections to ensure all steps have proper `instructions` arrays

#### 3.2 First Cook Screen = Ingredient Prep List
- **Issue:** Cook mode intro just shows stats, not what's needed
- **Requested:** First screen should show ALL ingredients needed for the recipe
- **File:** `/screens/CookScreen.tsx`
- **Implementation:** 
  - Modify `buildSteps()` function
  - Add intro step that aggregates all ingredients from all sections
  - Show as a checklist/prep list
  - User can mark items as "have" or skip

### Phase 4: AI Integration (NEXT)
**Priority:** MEDIUM - Complex

#### 4.1 Connect Import Recipe to Azure Foundry
- **Feature:** Import from link (web scraping)
- **Feature:** Import from photo (OCR + vision model)
- **Infrastructure needed:**
  - Azure Foundry endpoint config
  - API key management (environment variables)
  - Request/response types
  - Error handling for failed imports
- **Files to modify:**
  - `/utils/importRecipe.ts` (new or existing)
  - `/screens/ImportRecipeScreen.tsx`
  - `/app/.env` for API keys

---

## üèóÔ∏è IMAGE ARCHITECTURE DESIGN (New - Needs Discussion)

### Problem Statement
1. **Rate limits:** Sending images via chat causes issues
2. **App size:** Bundling images makes app huge
3. **Process:** Need systematic way to generate/acquire images

### Proposed Solution: Cloud-First Dynamic Loading

#### Architecture Overview
```
Recipe Schema (already done ‚úì)
‚îú‚îÄ‚îÄ imageUrl: string | null  <-- Points to cloud storage
‚îî‚îÄ‚îÄ emoji: string            <-- Fallback always present

Image Storage Options:
‚îú‚îÄ‚îÄ Option A: Supabase Storage (integrated, RLS, easy)
‚îú‚îÄ‚îÄ Option B: Cloudinary (optimized, CDN, transforms)
‚îú‚îÄ‚îÄ Option C: Azure Blob Storage (if already using Azure)
‚îî‚îÄ‚îÄ Option D: S3 + CloudFront (if AWS preference)

Image Generation Pipeline:
‚îú‚îÄ‚îÄ For manual recipes (our interactions)
‚îÇ   ‚îú‚îÄ‚îÄ You generate via DALL-E/Midjourney/Stable Diffusion
‚îÇ   ‚îî‚îÄ‚îÄ Upload to storage bucket via script or UI
‚îÇ
‚îî‚îÄ‚îÄ For AI-imported recipes (Foundry)
    ‚îú‚îÄ‚îÄ Recipe text goes to Foundry vision model
    ‚îú‚îÄ‚îÄ Model generates image
    ‚îî‚îÄ‚îÄ Auto-uploads to storage, returns URL
```

#### Implementation Plan

**Step 1: Storage Setup**
- Choose provider (recommend Supabase Storage for simplicity)
- Create bucket: `recipe-images`
- Set RLS policies (public read, authenticated write)
- Get base URL pattern

**Step 2: Recipe Schema (Already done ‚úì)**
- `imageUrl` field exists
- Fallback to emoji works

**Step 3: Image Loading**
- Use React Native `<Image>` with `{uri: imageUrl}`
- Add placeholder/loading state
- Cache images locally after first load (Expo FileSystem)

**Step 4: Upload Process**
```typescript
// New utility: /utils/imageUpload.ts
export async function uploadRecipeImage(
  recipeId: string, 
  imageUri: string
): Promise<string> {
  // Upload to Supabase Storage
  // Return public URL
  // Save URL to recipe.imageUrl
}
```

**Step 5: Generation Pipeline (Azure Foundry)**
```typescript
// New utility: /utils/generateRecipeImage.ts
export async function generateRecipeImage(
  recipeTitle: string,
  cuisine: string,
  ingredients: string[]
): Promise<string> {
  // Call Azure Foundry vision model
  // Generate prompt from recipe data
  // Get image blob
  // Upload to storage
  // Return URL
}
```

#### Storage Recommendations

**Primary recommendation: Supabase Storage**
- Already integrated with app
- No additional dependencies
- RLS policies for security
- Free tier generous (1GB)
- CDN edge caching

**Bucket structure:**
```
recipe-images/
‚îú‚îÄ‚îÄ tonkotsu-ramen.jpg
‚îú‚îÄ‚îÄ birria-tacos.jpg
‚îú‚îÄ‚îÄ cacio-e-pepe.jpg
‚îî‚îÄ‚îÄ [recipe-id].[ext]
```

**URL pattern:**
```
https://[project].supabase.co/storage/v1/object/public/recipe-images/[recipe-id].jpg
```

#### Workflow for Manual Recipes (Our Process)

1. **Create recipe** (you and me)
2. **Generate image** (you via your preferred tool)
3. **Upload image** via admin script or UI:
   ```bash
   # Script you can run
   npx tsx scripts/upload-recipe-image.ts \
     --recipe tonkotsu-ramen \
     --image ./tonkotsu-ramen.jpg
   ```
4. **Image loads dynamically** in app

#### Workflow for AI-Imported Recipes

1. **User imports recipe** (photo or link)
2. **Text extraction** (OCR or scraping)
3. **Recipe structured** (Foundry LLM)
4. **Image generation** (Foundry vision model)
5. **Auto-upload** to storage
6. **Recipe saved** with `imageUrl`

#### Rate Limit Solution

- **No chat images** for production recipes
- **Direct upload** to storage bypasses chat entirely
- **Script-based** or **admin UI** for batch uploads
- Foundry generation happens server-side, no chat involvement

---

## üìã IMMEDIATE NEXT ACTIONS (When Session Resumes)

### Option A: Continue Remaining Phases
1. Fix blank steps bug (Phase 3.1)
2. Add ingredient prep list to cook mode (Phase 3.2)
3. Design Azure Foundry integration (Phase 4)

### Option B: Deep Dive Image Architecture
1. Set up Supabase Storage bucket
2. Create image upload utility
3. Convert existing recipes to use cloud images
4. Remove Unsplash URLs, replace with uploaded images

### Option C: Hybrid Approach
1. Quick fix: Upload your AI-generated ramen image to test the flow
2. Then continue with cook mode fixes
3. Then formalize image pipeline

---

## üîß TECHNICAL DECISIONS NEEDED

### From You:
1. **Storage provider:** Supabase (recommended), Cloudinary, Azure, or S3?
2. **Image generation:** Which Azure Foundry model? GPT-4 Vision? DALL-E? Custom?
3. **Upload method:** Script, admin UI in app, or drag-drop web interface?
4. **Fallback strategy:** Always show emoji while loading? Skeleton? Gray box?

### From Me (ready to implement):
- Storage bucket setup
- Upload utilities
- Image loading with caching
- Foundry API integration
- Admin tools

---

## üìÅ FILES MODIFIED TODAY (Git Status Check)

New files:
- `/data/recipes/tonkotsu-ramen.ts`
- `/docs/RECIPE_SCHEMA.md`

Modified files:
- `/data/recipes/index.ts` (added tonkotsu, imageUrl support)
- `/app/(tabs)/index.tsx` (HomeScreen images + trending fix)
- `/screens/RecipeScreen.tsx` (hero image, servings fix)
- `/screens/CookScreen.tsx` (servings fix, tonkotsu route)
- `/screens/RecipeLibraryScreen.tsx` (card images)
- `/data/recipes/cacio-e-pepe.ts` (existing)

---

## üí¨ CONTEXT FOR NEW SESSION

**Say this when starting new session:**
> "Resume from TODO document. We completed Phase 1 and 2. Ready for Phase 3: [fix blank steps / add ingredient prep list / image architecture]. Here's the doc: /docs/TODO_2026-02-17.md"

**I will then:**
1. Read this document
2. Check current codebase state
3. Continue seamlessly from where we left off

---

## ‚ö†Ô∏è RATE LIMIT MITIGATION

Going forward:
- **No image uploads via chat** (causes limits)
- Use **storage URLs** instead
- Use **text descriptions** for image concepts
- Batch work into logical chunks

---

*Document version: 1.0*  
*Ready for session continuation*
